# Implementation Plan: Performance Optimization

**Branch**: `005-performance-optimization` | **Date**: 2025-12-11 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/005-performance-optimization/spec.md`

## Summary

Optimize game performance to maintain 55+ FPS with 100 gnomes and 2000+ tasks. Research identified three critical bottlenecks:

1. **Task Assignment**: O(N*M*P) complexity causing freeze - fix with throttling + attempt limits
2. **Pathfinding**: Unoptimized A* - fix with binary heap + Map lookups
3. **Rendering**: Graphics recreated every frame - fix with dirty flags + batching

## Technical Context

**Language/Version**: TypeScript 5.x (strict mode enabled)
**Primary Dependencies**: SvelteKit 2.x, PixiJS v8, Svelte 5.x
**Storage**: N/A (in-memory game state)
**Testing**: `pnpm check` (TypeScript), manual gameplay testing
**Target Platform**: Web browser (desktop)
**Project Type**: Single project (SvelteKit app)
**Performance Goals**: 55+ FPS with 100 gnomes, 2000 tasks
**Constraints**: <16ms per frame, responsive task assignment (<0.5s)
**Scale/Scope**: 100+ entities, 2000+ tasks, 60 TPS simulation

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Evidence |
|-----------|--------|----------|
| Type Safety First | ✅ Pass | All new code uses TypeScript strict, no `any` types |
| Entity-Component Architecture | ✅ Pass | No changes to ECS pattern, systems remain stateless |
| Documentation as Specification | ✅ Pass | research.md, data-model.md, contracts/ created |
| Simplicity and YAGNI | ✅ Pass | Starting with simple optimizations (throttle, heap) |
| Deterministic Game State | ✅ Pass | Throttling uses tick counter, not wall clock |

**Post-Design Re-check**: All principles satisfied. No complexity violations.

## Project Structure

### Documentation (this feature)

```text
specs/005-performance-optimization/
├── plan.md              # This file
├── spec.md              # Feature specification
├── research.md          # Performance analysis findings
├── data-model.md        # New data structures
├── quickstart.md        # Implementation guide
├── contracts/           # API contracts
│   └── performance-api.md
└── tasks.md             # (Generated by /speckit.tasks)
```

### Source Code (repository root)

```text
src/lib/
├── config/
│   ├── performance.ts   # NEW: Performance tuning constants
│   └── index.ts         # Updated: export performance
├── utils/
│   └── binary-heap.ts   # NEW: Priority queue implementation
├── systems/
│   ├── task-assignment.ts  # MODIFIED: Throttling + attempt limits
│   └── pathfinding.ts      # MODIFIED: Binary heap + Map lookups
└── render/
    └── renderer.ts         # MODIFIED: Batched task markers
```

**Structure Decision**: Single project structure maintained. New files added to existing directories following established patterns.

## Implementation Strategy

### Phase 1: Quick Wins (P1 - MVP)

Priority optimizations with highest impact-to-effort ratio:

1. **Throttle task assignment** - Run every 10 ticks instead of every tick
2. **Limit pathfinding attempts** - Max 10 attempts per gnome per cycle
3. **Batch task marker rendering** - Single stroke() call instead of N calls

**Expected Impact**: 10-50x improvement in task assignment system

### Phase 2: Algorithmic Improvements (P2)

Core algorithm optimizations:

1. **Binary heap for A* open set** - O(log n) vs O(n log n) per iteration
2. **Map-based open set lookups** - O(1) vs O(n) duplicate checking
3. **Numeric keys** - Avoid string allocation garbage

**Expected Impact**: 5-10x improvement in pathfinding

### Phase 3: Advanced Optimizations (P3)

Additional optimizations if needed:

1. **Path caching** - Reuse paths when world unchanged
2. **Dirty flags for rendering** - Only redraw changed entities
3. **Task cache** - Avoid re-sorting unchanged task list

**Expected Impact**: 2-5x additional improvement

### Phase 4: Future Considerations (P4)

Not in scope but documented for future:

1. Sprite-based rendering (replace Graphics with Sprites)
2. Jump Point Search for faster pathfinding
3. Web Workers for offloading computation

## Key Decisions

| Decision | Rationale | Alternatives Rejected |
|----------|-----------|----------------------|
| Throttle to 10 ticks | ~6 assignments/second is responsive enough | Every tick (too slow), 60 ticks (too unresponsive) |
| Custom binary heap | No external dependencies, simple implementation | heap-js library (adds dependency) |
| Numeric coordinate keys | x*10000+y avoids string allocation | String keys (garbage creation) |
| Attempt limit of 10 | Balances thorough search vs CPU time | Unlimited (can freeze), 3 (may miss valid tasks) |

## Success Metrics

| Metric | Current | Target | How to Measure |
|--------|---------|--------|----------------|
| FPS (44 gnomes + 2000 tasks) | 0 | 55+ | In-game FPS counter |
| FPS (100 gnomes + 2000 tasks) | N/A | 55+ | In-game FPS counter |
| Task assignment responsiveness | Freeze | <0.5s | Visual observation |
| Camera pan smoothness | Stuttery | Smooth | Visual observation |

## Complexity Tracking

No constitution violations requiring justification.

## Next Steps

Run `/speckit.tasks` to generate the implementation task list.
